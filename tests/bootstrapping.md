
# Bootstrapping a Consumer chain

Create a branch and a corresponding `*-dev` branch from the `main` or dev branches of `multiverse`. The "appname" placeholders need to
all be replaced. Any extra modules need to be included in app.go. Any proposals that are added need
to be added to `proposals_whitelisting.go`. Some tests for the existence of new commands should be
tested in `ics_with_onomyd` to make sure the module was integrated. The `*-dev` branch can be PRed
into its corresponding main branch for CI, and then a `vx.y.z-name` tag can be created to build a
binary.

The Swagger OpenAPI may need to be regenerated by following the instructions in `multiverse/docs/docs.go`.

Here is an overview of the bootstrapping process.
Bootstrapping a consumer chain in the `ics_with_onomyd` test works in the following order:
- The provider is setup and run
- `tendermint show-validator` is used to obtain the key that will be used by the consumer (this should be a ed25519 tendermint pubkey used in validator signing and not the sepk key used in transaction signing)
- a "consumer-addition" proposal is filed with "chain_id" being the same id that is used by the consumer. For the test, the dates are set in the past.
- After the proposal passes, we get the ccv state by `... query provider consumer-genesis -o json` and set the missing "soft_opt_out_threshold", "provider_reward_denoms", and "reward_denoms" fields (this is an issue that should be fixed by a future ICS version)
- the ccv state (which bootstraps the consumer's knowledge of the provider powers and tendermint keys) and keys are sent to the consumer node
- The state is used to complete the genesis and start the consumer node
- Hermes has a config with the two chains, with `ccv_consumer_chain = true` for the consumer chain. We add the mnemonics for accounts on both chains to hermes.
- `hermes_setup_ics_pair` is called which creats the ICS-specific IBC channels (more on that later)
- Hermes is started and begins to relay packets. Note that until the first CCV packets start arriving, the consumer chain is in a pre-CCV state that disables most kinds of transactions, and if you get "tx contains unsupported message types" then it means that Hermes might not be working.
- The test then tests various things involving using IBC transfer tokens for gas prices and such, governance changes, and any commands relevant to the specific chain

Here is the process for a real chain.
- Validators agree on a genesis for the consumer chain. We don't know the CCV state yet, so "ccvconsumer" is left in an empty state. The normal validator set can be left empty. An example genesis can be obtained by getting a test genesis from the `ics_with_onomyd` test, which should be modified to obtain a testnet or mainnet ready genesis.
- Someone creates a "consumer-addition" file proposal with the argument file
```
{
    "title": "Propose the addition of a new chain",
    "description": "Add the [name] consumer chain",
    "chain_id": "[chain-id]",
    "initial_height": {
        "revision_number": 0,
        "revision_height": 1
    },
    "genesis_hash": "Z2VuX2hhc2g=",
    "binary_hash": "YmluX2hhc2g=",
    "spawn_time": "2023-05-18T01:15:49.83019476-05:00",
    "unbonding_period": 1728000000000000,
    "consumer_redistribution_fraction": "0.5",
    "provider_reward_denoms": ["anom"],
    "reward_denoms": ["anative"],
    "blocks_per_distribution_transmission": 1000,
    "soft_opt_out_threshold": "0.0",
    "historical_entries": 10000,
    "ccv_timeout_period": 2419200000000000,
    "transfer_timeout_period": 3600000000000,
    "deposit": "500000000000000000000anom"
}
```
- chain-id and the "revision_number" must correspond, or else tendermint clients can be broken. If a chain id has no number on the end, then "revision_number" should be 0. If the chain id is something like `asdf-testnet-7` with a dash and a number, then the "revision_number" should be 7 to correspond.
- "genesis_hash" is used for off-chain confirmation of the genesis state without CCV state (e.x. `cat genesis.json | openssl dgst -binary -sha256 | openssl base64 -A`)
- "binary_hash" is used for off-chain confirmation of the hash of the initialization binary
- "spawn_time" is the time at which the timeout periods begin and CCV state is available. This should be set to shortly after the proposal passes and not too long before the "genesis_time" in the consumer genesis. The "genesis_time" in the genesis is when validators will be responsible for starting their consumer binaries
- "unbonding_period" is the unbonding period, should be less than the unbonding period for the provider (e.x. 24 hours less than the standard 21 days)
- "ccv_timeout_period" timeout period of CCV related IBC packets
- "transfer_timeout_period" timeout period of transfer related IBC packets
- "consumer_redistribution_fraction": "0.75" means that 75% of distribution events will be allocated to be sent back to the provider through the `cons_redistribute` address
- "soft_opt_out_threshold" should only be nonzero on really large PoS provider chains that want to be easier on smaller validators, Onomy is more strict
- "deposit" the deposit is included with the proposal command, which is 500 NOM for Onomy

We want to avoid situations where a misconfiguration causes an error that only happens after the consumer chain is brought online, and especially misconfigurations that are built into the proposal (If it would pass, then we would have to make a consumer removal proposal). The `onomy_tests` repo has `onex_genesis` which modifies the standard ICS test to use a prespecified proposal and partial genesis to test this. It works for a single node and single dealer account for testnets, but may need to be modified for cases with more than one validator.

Before the CCV state is obtained (a team member usually does this shortly after the consumer addition proposal passes), any validator that wants to use a different tendermint key than what they use for the provider must run 
`[provider binary] tx provider assign-consensus-key [consumer chain id] [tendermint key] [flags]` (note: it should be an ed25519 tendermint validator key and not a secp256k1 key)

The CCV state is obtained by `[provider binary] query provider consumer genesis [consumer chain id]` after the "spawn_time" is passed. This is inserted into the consumer genesis to complete it. This is passed along to the validators who start their nodes in preparation for "genesis_time".

If the consumer chain has its own staking coin that is used in th redistribution rewards, someone needs to run `[provider binary] tx provider register-consumer-reward-denom [IBC-version-of-consumer-reward-denom]` in order for redistribution to start working later.

Before chain start, most validators will need to copy the tendermint keys from their provider node to their consumer node (excepting if they chose a different key by "assign-consensus-key" _before_ the CCV state was obtained, in which case they need that key). Specifically, `$PROVIDER_HOME/config/priv_validator_key.json` needs to be copied to `$CONSUMER_HOME/config/priv_validator_key.json`. The provider and consumer node could be run together on the same machine as long as separate sets of ports are assigned, or else they can go on different machines.

Upon chain start, the ICS channel needs to be initiated (this should be done by a team member with access to a provider node and a consumer node). The ICS modules automatically create 07-tendermint clients on both chains. This is always 07-tendermint-0 for the consumer, and the corresponding one on the provider needs to be found. For Hermes, the "--a-client" must be the consumer chain, and the "--b-client" must be the provider chain.
- create the connection with `hermes create connection --a-chain [consumer id] --a-client 07-tendermint-0 --b-client [correct provider client]`
- create the channel with `hermes create channel --a-chain [consumer id] --a-connection connection-0 --a-port consumer --b-port provider --order ordered`

Upon provider-consumer channel creation, ICS will automatically create a transfer-transfer channel on both sides. The first `chan-open-init` step is done already, but the remaining 3 manual channel opening steps need to be manually done to complete the process. This works like:

- `hermes tx chan-open-try --dst-chain {provider} --src-chain {consumer} --dst-connection {provider_connection} --dst-port transfer --src-port transfer --src-channel {consumer_channel}`
- `hermes tx chan-open-ack --dst-chain {consumer} --src-chain {provider} --dst-connection {consumer_connection} --dst-port transfer --src-port transfer --dst-channel {consumer_channel} --src-channel {provider_channel}`
- `hermes tx chan-open-confirm --dst-chain {provider} --src-chain {consumer} --dst-connection {provider_connection} --dst-port transfer --src-port transfer --dst-channel {provider_channel} --src-channel {consumer_channel}`

where `consumer_connection` should always be "connection-0" and `consumer_channel` should always be "channel-1" (the provider-consumer channel was "channel-0"), and the other values need to be determined from how they were initialized earlier

A Hermes relayer should be started, and if after this there are no "tx contains unsupported message types" errors from any non-IBC transactions on the consumer chain, and if a ibc-transfer can be performed over `channel-1`, then bootstrap is complete.

Hermes `ft-transfer` is a very flaky transaction. In testnet practice, the timeouts had to be manually specified otherwise a "packet timeout height and packet timeout timestamp cannot both be 0" error would be issued `hermes tx ft-transfer --dst-chain [consumer-id] --src-chain [provider-id] --src-port transfer --src-channel channel-4 --amount 100000000000 --denom anom --timeout-height-offset 20 --timeout-seconds 120`.

For governance, consumer-side validators can be created like `[consumer binary] tx staking create-validator --commission-max-change-rate 0.01 --commission-max-rate 0.10 --commission-rate 0.05 --min-self-delegation 1 --amount 100000000000stake --from validator --pubkey '{"@type":"/cosmos.crypto.ed25519.PubKey","key":"1vMo7NN5rvX06zVmJ61KG00/KZB0H3rsmsoslRyaBds="}' -y -b block --fees 1000000anom`. These validators do not sign blocks and are used just for bonding and voting in consumer-side governance. Each replicated security validator could use their provider key for the `--pubkey` argument.

